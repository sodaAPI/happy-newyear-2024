import {
  loadEmittersPlugin,
  loadLifeUpdater,
  loadRotateUpdater
} from "./chunk-FJ7BXDON.js";
import {
  loadBasic
} from "./chunk-OXELOQTJ.js";
import {
  OptionsColor,
  ValueWithRandom,
  clamp,
  deepExtend,
  executeOnSingleOrMultiple,
  getHslAnimationFromHsl,
  getLogger,
  getRangeValue,
  getValue,
  isArray,
  isFunction,
  isNumber,
  isObject,
  isString,
  itemFromArray,
  itemFromSingleOrMultiple,
  loadParticlesOptions,
  randomInRange,
  rangeColorToHsl,
  rgbToHsl,
  setRangeValue,
  stringToRgb
} from "./chunk-ADUCJV7J.js";
import "./chunk-LQ2VYIYD.js";

// node_modules/tsparticles-updater-destroy/esm/Options/Classes/DestroyBounds.js
var DestroyBounds = class {
  load(data) {
    if (!data) {
      return;
    }
    if (data.bottom !== void 0) {
      this.bottom = setRangeValue(data.bottom);
    }
    if (data.left !== void 0) {
      this.left = setRangeValue(data.left);
    }
    if (data.right !== void 0) {
      this.right = setRangeValue(data.right);
    }
    if (data.top !== void 0) {
      this.top = setRangeValue(data.top);
    }
  }
};

// node_modules/tsparticles-updater-destroy/esm/Options/Classes/SplitFactor.js
var SplitFactor = class extends ValueWithRandom {
  constructor() {
    super();
    this.value = 3;
  }
};

// node_modules/tsparticles-updater-destroy/esm/Options/Classes/SplitRate.js
var SplitRate = class extends ValueWithRandom {
  constructor() {
    super();
    this.value = { min: 4, max: 9 };
  }
};

// node_modules/tsparticles-updater-destroy/esm/Options/Classes/Split.js
var Split = class {
  constructor() {
    this.count = 1;
    this.factor = new SplitFactor();
    this.rate = new SplitRate();
    this.sizeOffset = true;
  }
  load(data) {
    if (!data) {
      return;
    }
    if (data.color !== void 0) {
      this.color = OptionsColor.create(this.color, data.color);
    }
    if (data.count !== void 0) {
      this.count = data.count;
    }
    this.factor.load(data.factor);
    this.rate.load(data.rate);
    this.particles = executeOnSingleOrMultiple(data.particles, (particles) => {
      return deepExtend({}, particles);
    });
    if (data.sizeOffset !== void 0) {
      this.sizeOffset = data.sizeOffset;
    }
    if (data.colorOffset) {
      this.colorOffset = this.colorOffset ?? {};
      if (data.colorOffset.h !== void 0) {
        this.colorOffset.h = data.colorOffset.h;
      }
      if (data.colorOffset.s !== void 0) {
        this.colorOffset.s = data.colorOffset.s;
      }
      if (data.colorOffset.l !== void 0) {
        this.colorOffset.l = data.colorOffset.l;
      }
    }
  }
};

// node_modules/tsparticles-updater-destroy/esm/Options/Classes/Destroy.js
var Destroy = class {
  constructor() {
    this.bounds = new DestroyBounds();
    this.mode = "none";
    this.split = new Split();
  }
  load(data) {
    if (!data) {
      return;
    }
    if (data.mode) {
      this.mode = data.mode;
    }
    if (data.bounds) {
      this.bounds.load(data.bounds);
    }
    this.split.load(data.split);
  }
};

// node_modules/tsparticles-updater-destroy/esm/Utils.js
function addSplitParticle(engine, container, parent, splitParticlesOptions) {
  const destroyOptions = parent.options.destroy;
  if (!destroyOptions) {
    return;
  }
  const splitOptions = destroyOptions.split, options2 = loadParticlesOptions(engine, container, parent.options), factor = getValue(splitOptions.factor), parentColor = parent.getFillColor();
  if (splitOptions.color) {
    options2.color.load(splitOptions.color);
  } else if (splitOptions.colorOffset && parentColor) {
    options2.color.load({
      value: {
        hsl: {
          h: parentColor.h + getRangeValue(splitOptions.colorOffset.h ?? 0),
          s: parentColor.s + getRangeValue(splitOptions.colorOffset.s ?? 0),
          l: parentColor.l + getRangeValue(splitOptions.colorOffset.l ?? 0)
        }
      }
    });
  } else {
    options2.color.load({
      value: {
        hsl: parent.getFillColor()
      }
    });
  }
  options2.move.load({
    center: {
      x: parent.position.x,
      y: parent.position.y,
      mode: "precise"
    }
  });
  if (isNumber(options2.size.value)) {
    options2.size.value /= factor;
  } else {
    options2.size.value.min /= factor;
    options2.size.value.max /= factor;
  }
  options2.load(splitParticlesOptions);
  const offset = splitOptions.sizeOffset ? setRangeValue(-parent.size.value, parent.size.value) : 0, position = {
    x: parent.position.x + randomInRange(offset),
    y: parent.position.y + randomInRange(offset)
  };
  return container.particles.addParticle(position, options2, parent.group, (particle) => {
    if (particle.size.value < 0.5) {
      return false;
    }
    particle.velocity.length = randomInRange(setRangeValue(parent.velocity.length, particle.velocity.length));
    particle.splitCount = (parent.splitCount ?? 0) + 1;
    particle.unbreakable = true;
    setTimeout(() => {
      particle.unbreakable = false;
    }, 500);
    return true;
  });
}
function split(engine, container, particle) {
  const destroyOptions = particle.options.destroy;
  if (!destroyOptions) {
    return;
  }
  const splitOptions = destroyOptions.split;
  if (splitOptions.count >= 0 && (particle.splitCount === void 0 || particle.splitCount++ > splitOptions.count)) {
    return;
  }
  const rate = getValue(splitOptions.rate), particlesSplitOptions = itemFromSingleOrMultiple(splitOptions.particles);
  for (let i = 0; i < rate; i++) {
    addSplitParticle(engine, container, particle, particlesSplitOptions);
  }
}

// node_modules/tsparticles-updater-destroy/esm/DestroyUpdater.js
var DestroyUpdater = class {
  constructor(engine, container) {
    this.engine = engine;
    this.container = container;
  }
  init(particle) {
    const container = this.container, particlesOptions = particle.options, destroyOptions = particlesOptions.destroy;
    if (!destroyOptions) {
      return;
    }
    particle.splitCount = 0;
    const destroyBoundsOptions = destroyOptions.bounds;
    if (!particle.destroyBounds) {
      particle.destroyBounds = {};
    }
    const { bottom, left, right, top } = destroyBoundsOptions, { destroyBounds } = particle, canvasSize = container.canvas.size;
    if (bottom) {
      destroyBounds.bottom = getRangeValue(bottom) * canvasSize.height / 100;
    }
    if (left) {
      destroyBounds.left = getRangeValue(left) * canvasSize.width / 100;
    }
    if (right) {
      destroyBounds.right = getRangeValue(right) * canvasSize.width / 100;
    }
    if (top) {
      destroyBounds.top = getRangeValue(top) * canvasSize.height / 100;
    }
  }
  isEnabled(particle) {
    return !particle.destroyed;
  }
  loadOptions(options2, ...sources) {
    if (!options2.destroy) {
      options2.destroy = new Destroy();
    }
    for (const source of sources) {
      options2.destroy.load(source == null ? void 0 : source.destroy);
    }
  }
  particleDestroyed(particle, override) {
    if (override) {
      return;
    }
    const destroyOptions = particle.options.destroy;
    if (destroyOptions && destroyOptions.mode === "split") {
      split(this.engine, this.container, particle);
    }
  }
  update(particle) {
    if (!this.isEnabled(particle)) {
      return;
    }
    const position = particle.getPosition(), bounds = particle.destroyBounds;
    if (!bounds) {
      return;
    }
    if (bounds.bottom !== void 0 && position.y >= bounds.bottom || bounds.left !== void 0 && position.x <= bounds.left || bounds.right !== void 0 && position.x >= bounds.right || bounds.top !== void 0 && position.y <= bounds.top) {
      particle.destroy();
    }
  }
};

// node_modules/tsparticles-updater-destroy/esm/index.js
async function loadDestroyUpdater(engine, refresh = true) {
  await engine.addParticleUpdater("destroy", (container) => new DestroyUpdater(engine, container), refresh);
}

// node_modules/tsparticles-shape-line/esm/LineDrawer.js
var LineDrawer = class {
  draw(context, particle, radius) {
    const shapeData = particle.shapeData;
    context.moveTo(-radius / 2, 0);
    context.lineTo(radius / 2, 0);
    context.lineCap = (shapeData == null ? void 0 : shapeData.cap) ?? "butt";
  }
  getSidesCount() {
    return 1;
  }
};

// node_modules/tsparticles-shape-line/esm/index.js
async function loadLineShape(engine, refresh = true) {
  await engine.addShape("line", new LineDrawer(), refresh);
}

// node_modules/tsparticles-plugin-sounds/esm/Options/Classes/SoundsAudio.js
var SoundsAudio = class {
  constructor() {
    this.loop = false;
    this.source = "";
  }
  load(data) {
    if (data === void 0) {
      return;
    }
    if (isObject(data)) {
      if (data.loop !== void 0) {
        this.loop = data.loop;
      }
      if (data.source !== void 0) {
        this.source = data.source;
      }
    } else {
      this.source = data;
    }
  }
};

// node_modules/tsparticles-plugin-sounds/esm/Options/Classes/SoundsNote.js
var SoundsNote = class {
  constructor() {
    this.duration = 500;
    this.value = [];
  }
  load(data) {
    if (!data) {
      return;
    }
    if (data.duration !== void 0) {
      this.duration = data.duration;
    }
    if (data.value !== void 0) {
      this.value = data.value;
    }
  }
};

// node_modules/tsparticles-plugin-sounds/esm/Options/Classes/SoundsMelody.js
var SoundsMelody = class _SoundsMelody {
  constructor() {
    this.loop = false;
    this.melodies = [];
    this.notes = [];
  }
  load(data) {
    if (data === void 0) {
      return;
    }
    if (data.loop !== void 0) {
      this.loop = data.loop;
    }
    if (data.melodies !== void 0) {
      this.melodies = data.melodies.map((s) => {
        const tmp = new _SoundsMelody();
        tmp.load(s);
        return tmp;
      });
    }
    if (data.notes !== void 0) {
      this.notes = data.notes.map((s) => {
        const tmp = new SoundsNote();
        tmp.load(s);
        return tmp;
      });
    }
  }
};

// node_modules/tsparticles-plugin-sounds/esm/Options/Classes/SoundsEvent.js
var SoundsEvent = class {
  constructor() {
    this.event = [];
    this.notes = [];
  }
  load(data) {
    if (!data) {
      return;
    }
    if (data.event !== void 0) {
      this.event = data.event;
    }
    if (data.audio !== void 0) {
      if (isArray(data.audio)) {
        this.audio = data.audio.map((s) => {
          const tmp = new SoundsAudio();
          tmp.load(s);
          return tmp;
        });
      } else {
        this.audio = new SoundsAudio();
        this.audio.load(data.audio);
      }
    }
    if (data.notes !== void 0) {
      this.notes = data.notes.map((t) => {
        const tmp = new SoundsNote();
        tmp.load(t);
        return tmp;
      });
    }
    if (data.melodies !== void 0) {
      this.melodies = data.melodies.map((t) => {
        const tmp = new SoundsMelody();
        tmp.load(t);
        return tmp;
      });
    }
    if (data.filter !== void 0) {
      if (isString(data.filter)) {
        if (isFunction(window[data.filter])) {
          this.filter = window[data.filter];
        }
      } else {
        this.filter = data.filter;
      }
    }
  }
};

// node_modules/tsparticles-plugin-sounds/esm/Options/Classes/SoundsIcon.js
var SoundsIcon = class {
  constructor() {
    this.width = 24;
    this.height = 24;
  }
  load(data) {
    if (!data) {
      return;
    }
    if (data.path !== void 0) {
      this.path = data.path;
    }
    if (data.svg !== void 0) {
      this.svg = data.svg;
    }
    if (data.width !== void 0) {
      this.width = data.width;
    }
    if (data.height !== void 0) {
      this.height = data.height;
    }
  }
};

// node_modules/tsparticles-plugin-sounds/esm/Options/Classes/SoundsIcons.js
var SoundsIcons = class {
  constructor() {
    this.mute = new SoundsIcon();
    this.unmute = new SoundsIcon();
    this.volumeDown = new SoundsIcon();
    this.volumeUp = new SoundsIcon();
    this.mute.svg = `<?xml version="1.0"?>
<svg baseProfile="tiny" height="24px" version="1.2" viewBox="0 0 24 24" width="24px"
    xml:space="preserve" xmlns="http://www.w3.org/2000/svg"
    xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="Layer_1">
        <path fill="#fff" d="M19.707,5.293c-0.391-0.391-1.023-0.391-1.414,0l-1.551,1.551c-0.345-0.688-0.987-1.02-1.604-1.02c-0.449,0-0.905,0.152-1.356,0.453l-2.672,1.781C10.357,8.561,8.904,9,8,9c-1.654,0-3,1.346-3,3v2c0,1.237,0.754,2.302,1.826,2.76l-1.533,1.533c-0.391,0.391-0.391,1.023,0,1.414C5.488,19.902,5.744,20,6,20s0.512-0.098,0.707-0.293l2.527-2.527c0.697,0.174,1.416,0.455,1.875,0.762l2.672,1.781c0.451,0.301,0.907,0.453,1.356,0.453C16.035,20.176,17,19.495,17,18V9.414l2.707-2.707C20.098,6.316,20.098,5.684,19.707,5.293z M14.891,7.941c0.038-0.025,0.073-0.046,0.104-0.062C14.998,7.914,15,7.954,15,8v1.293l-2,2V9.202L14.891,7.941z M7,12c0-0.552,0.448-1,1-1c1.211,0,2.907-0.495,4-1.146v2.439l-2.83,2.83C8.757,15.046,8.356,15,8,15c-0.552,0-1-0.448-1-1V12z M10.301,15.406L12,13.707v2.439C11.519,15.859,10.925,15.604,10.301,15.406z M14.994,18.12c-0.03-0.016-0.065-0.036-0.104-0.062L13,16.798v-4.091l2-2V18C15,18.046,14.998,18.086,14.994,18.12z"/>
    </g>
</svg>`;
    this.unmute.svg = `<?xml version="1.0"?>
<svg baseProfile="tiny" height="24px" version="1.2" viewBox="0 0 24 24" width="24px"
    xml:space="preserve" xmlns="http://www.w3.org/2000/svg"
    xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="Layer_1">
        <path fill="#fff" d="M17.138,5.824c-0.449,0-0.905,0.152-1.356,0.453l-2.672,1.781C12.357,8.561,10.904,9,10,9c-1.654,0-3,1.346-3,3v2c0,1.654,1.346,3,3,3c0.904,0,2.357,0.439,3.109,0.941l2.672,1.781c0.451,0.301,0.907,0.453,1.356,0.453C18.035,20.176,19,19.495,19,18V8C19,6.505,18.035,5.824,17.138,5.824z M14,16.146C12.907,15.495,11.211,15,10,15c-0.552,0-1-0.448-1-1v-2c0-0.552,0.448-1,1-1c1.211,0,2.907-0.495,4-1.146V16.146z M17,18c0,0.046-0.002,0.086-0.006,0.12c-0.03-0.016-0.065-0.036-0.104-0.062L15,16.798V9.202l1.891-1.261c0.038-0.025,0.073-0.046,0.104-0.062C16.998,7.914,17,7.954,17,8V18z"/>
    </g>
</svg>`;
    this.volumeDown.svg = `<?xml version="1.0"?>
<svg baseProfile="tiny" height="24px" version="1.2" viewBox="0 0 24 24" width="24px"
    xml:space="preserve" xmlns="http://www.w3.org/2000/svg"
    xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="Layer_1">
        <path fill="#fff" d="M15.138,5.824c-0.449,0-0.905,0.152-1.356,0.453l-2.672,1.781C10.357,8.561,8.904,9,8,9c-1.654,0-3,1.346-3,3v2c0,1.654,1.346,3,3,3c0.904,0,2.357,0.439,3.109,0.941l2.672,1.781c0.451,0.301,0.907,0.453,1.356,0.453C16.035,20.176,17,19.495,17,18V8C17,6.505,16.035,5.824,15.138,5.824z M8,15c-0.552,0-1-0.448-1-1v-2c0-0.552,0.448-1,1-1c1.211,0,2.907-0.495,4-1.146v6.293C10.907,15.495,9.211,15,8,15z M15,18c0,0.046-0.002,0.086-0.006,0.12c-0.03-0.016-0.065-0.036-0.104-0.062L13,16.798V9.202l1.891-1.261c0.038-0.025,0.073-0.046,0.104-0.062C14.998,7.914,15,7.954,15,8V18z"/>
        <path fill="#fff" d="M18.292,10.294c-0.39,0.391-0.39,1.023,0.002,1.414c0.345,0.345,0.535,0.803,0.535,1.291c0,0.489-0.19,0.948-0.536,1.294c-0.391,0.39-0.391,1.023,0,1.414C18.488,15.902,18.744,16,19,16s0.512-0.098,0.707-0.293c0.724-0.723,1.122-1.685,1.122-2.708s-0.398-1.984-1.123-2.707C19.317,9.903,18.683,9.901,18.292,10.294z"/>
    </g>
</svg>`;
    this.volumeUp.svg = `<?xml version="1.0"?>
<svg baseProfile="tiny" height="24px" version="1.2" viewBox="0 0 24 24" width="24px"
    xml:space="preserve" xmlns="http://www.w3.org/2000/svg"
    xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="Layer_1">
        <path fill="#fff" d="M16.706,10.292c-0.389-0.389-1.023-0.391-1.414,0.002c-0.39,0.391-0.39,1.023,0.002,1.414c0.345,0.345,0.535,0.803,0.535,1.291c0,0.489-0.19,0.948-0.536,1.294c-0.391,0.39-0.391,1.023,0,1.414C15.488,15.902,15.744,16,16,16s0.512-0.098,0.707-0.293c0.724-0.723,1.122-1.685,1.122-2.708S17.431,11.015,16.706,10.292z"/>
        <path fill="#fff" d="M18.706,8.292c-0.391-0.389-1.023-0.39-1.414,0.002c-0.39,0.391-0.39,1.024,0.002,1.414c0.879,0.877,1.363,2.044,1.364,3.287c0.001,1.246-0.484,2.417-1.365,3.298c-0.391,0.391-0.391,1.023,0,1.414C17.488,17.902,17.744,18,18,18s0.512-0.098,0.707-0.293c1.259-1.259,1.952-2.933,1.951-4.713C20.657,11.217,19.964,9.547,18.706,8.292z"/>
        <path fill="#fff" d="M20.706,6.292c-0.391-0.389-1.023-0.39-1.414,0.002c-0.39,0.391-0.39,1.024,0.002,1.414c1.412,1.409,2.191,3.285,2.192,5.284c0.002,2.002-0.777,3.885-2.193,5.301c-0.391,0.391-0.391,1.023,0,1.414C19.488,19.902,19.744,20,20,20s0.512-0.098,0.707-0.293c1.794-1.794,2.781-4.18,2.779-6.717C23.485,10.457,22.497,8.078,20.706,6.292z"/>
        <path fill="#fff" d="M12.138,5.824c-0.449,0-0.905,0.152-1.356,0.453L8.109,8.059C7.357,8.561,5.904,9,5,9c-1.654,0-3,1.346-3,3v2c0,1.654,1.346,3,3,3c0.904,0,2.357,0.439,3.109,0.941l2.672,1.781c0.451,0.301,0.907,0.453,1.356,0.453C13.035,20.176,14,19.495,14,18V8C14,6.505,13.035,5.824,12.138,5.824z M5,15c-0.552,0-1-0.448-1-1v-2c0-0.552,0.448-1,1-1c1.211,0,2.907-0.495,4-1.146v6.293C7.907,15.495,6.211,15,5,15z M12,18c0,0.046-0.002,0.086-0.006,0.12c-0.03-0.016-0.065-0.036-0.104-0.062L10,16.798V9.202l1.891-1.261c0.038-0.025,0.073-0.046,0.104-0.062C11.998,7.914,12,7.954,12,8V18z"/>
    </g>
</svg>`;
  }
  load(data) {
    if (!data) {
      return;
    }
    this.mute.load(data.mute);
    this.unmute.load(data.unmute);
    this.volumeDown.load(data.volumeDown);
    this.volumeUp.load(data.volumeUp);
  }
};

// node_modules/tsparticles-plugin-sounds/esm/Options/Classes/SoundsVolume.js
var SoundsVolume = class {
  constructor() {
    this.value = 100;
    this.max = 100;
    this.min = 0;
    this.step = 10;
  }
  load(data) {
    if (data === void 0) {
      return;
    }
    if (isObject(data)) {
      if (data.max !== void 0) {
        this.max = data.max;
      }
      if (data.min !== void 0) {
        this.min = data.min;
      }
      if (data.step !== void 0) {
        this.step = data.step;
      }
      if (data.value !== void 0) {
        this.value = data.value;
      }
    } else {
      this.value = data;
    }
  }
};

// node_modules/tsparticles-plugin-sounds/esm/Options/Classes/Sounds.js
var Sounds = class {
  constructor() {
    this.enable = false;
    this.events = [];
    this.icons = new SoundsIcons();
    this.volume = new SoundsVolume();
  }
  load(data) {
    if (!data) {
      return;
    }
    if (data.enable !== void 0) {
      this.enable = data.enable;
    }
    if (data.events !== void 0) {
      this.events = data.events.map((t) => {
        const event = new SoundsEvent();
        event.load(t);
        return event;
      });
    }
    this.icons.load(data.icons);
    if (data.volume !== void 0) {
      this.volume.load(data.volume);
    }
  }
};

// node_modules/tsparticles-plugin-sounds/esm/utils.js
var notes = /* @__PURE__ */ new Map();
notes.set("C", [16.35, 32.7, 65.41, 130.81, 261.63, 523.25, 1046.5, 2093, 4186.01]);
notes.set("Db", [17.32, 34.65, 69.3, 138.59, 277.18, 554.37, 1108.73, 2217.46, 4434.92]);
notes.set("D", [18.35, 36.71, 73.42, 146.83, 293.66, 587.33, 1174.66, 2349.32, 4698.63]);
notes.set("Eb", [19.45, 38.89, 77.78, 155.56, 311.13, 622.25, 1244.51, 2489.02, 4978.03]);
notes.set("E", [20.6, 41.2, 82.41, 164.81, 329.63, 659.25, 1318.51, 2637.02, 5274.04]);
notes.set("F", [21.83, 43.65, 87.31, 174.61, 349.23, 698.46, 1396.91, 2793.83, 5587.65]);
notes.set("Gb", [23.12, 46.25, 92.5, 185, 369.99, 739.99, 1479.98, 2959.96, 5919.91]);
notes.set("G", [24.5, 49, 98, 196, 392, 783.99, 1567.98, 3135.96, 6271.93]);
notes.set("Ab", [25.96, 51.91, 103.83, 207.65, 415.3, 830.61, 1661.22, 3322.44, 6644.88]);
notes.set("A", [27.5, 55, 110, 220, 440, 880, 1760, 3520, 7040]);
notes.set("Bb", [29.14, 58.27, 116.54, 233.08, 466.16, 932.33, 1864.66, 3729.31, 7458.62]);
notes.set("B", [30.87, 61.74, 123.47, 246.94, 493.88, 987.77, 1975.53, 3951.07, 7902.13]);
notes.set("pause", [0]);
function getNoteFrequency(note) {
  const regex = /(([A-G]b?)(\d))|pause/i, result = regex.exec(note);
  if (!result || !result.length) {
    return;
  }
  const noteKey = result[2] || result[0], noteItem = notes.get(noteKey);
  if (!noteItem) {
    return;
  }
  return noteItem[parseInt(result[3] || "0")];
}

// node_modules/tsparticles-plugin-sounds/esm/SoundsInstance.js
function initImage(data) {
  var _a;
  const img = document.createElement("img"), { clickCb, container, display, iconOptions, margin, options: options2, pos, rightOffsets } = data, { width, path, svg } = iconOptions;
  setIconStyle(img, pos.top + margin, pos.right - (margin * (rightOffsets.length + 1) + width + rightOffsets.reduce((a, b) => a + b, 0)), display, options2.fullScreen.zIndex + 1, width, margin);
  img.src = path ?? (svg ? `data:image/svg+xml;base64,${btoa(svg)}` : "");
  const parent = ((_a = container.canvas.element) == null ? void 0 : _a.parentNode) || document.body;
  parent.append(img);
  img.addEventListener("click", clickCb);
  return img;
}
function removeImage(image) {
  if (!image) {
    return;
  }
  image.remove();
}
function setIconStyle(icon, top, left, display, zIndex, width, margin) {
  icon.style.userSelect = "none";
  icon.style.webkitUserSelect = "none";
  icon.style.position = "absolute";
  icon.style.top = `${top + margin}px`;
  icon.style.left = `${left - margin - width}px`;
  icon.style.display = display;
  icon.style.zIndex = `${zIndex + 1}`;
}
var SoundsInstance = class {
  constructor(container, engine) {
    this._addBuffer = (audioCtx) => {
      const buffer = audioCtx.createBufferSource();
      this._audioSources.push(buffer);
      return buffer;
    };
    this._addOscillator = (audioCtx) => {
      const oscillator = audioCtx.createOscillator();
      this._audioSources.push(oscillator);
      return oscillator;
    };
    this._initEvents = () => {
      const container2 = this._container, soundsOptions = container2.actualOptions.sounds;
      if (!(soundsOptions == null ? void 0 : soundsOptions.enable) || !container2.canvas.element) {
        return;
      }
      for (const event of soundsOptions.events) {
        const cb = async (args) => {
          if (this._container !== args.container) {
            return;
          }
          if (!this._container || this._container.muted || this._container.destroyed) {
            executeOnSingleOrMultiple(event.event, (item) => {
              this._engine.removeEventListener(item, cb);
            });
            return;
          }
          if (event.filter && !event.filter(args)) {
            return;
          }
          if (event.audio) {
            this._playBuffer(itemFromSingleOrMultiple(event.audio));
          } else if (event.melodies) {
            const melody = itemFromArray(event.melodies);
            if (melody.melodies.length) {
              await Promise.allSettled(melody.melodies.map((m) => this._playNote(m.notes, 0, melody.loop)));
            } else {
              await this._playNote(melody.notes, 0, melody.loop);
            }
          } else if (event.notes) {
            const note = itemFromArray(event.notes);
            await this._playNote([note], 0, false);
          }
        };
        executeOnSingleOrMultiple(event.event, (item) => {
          this._engine.addEventListener(item, cb);
        });
      }
    };
    this._mute = () => {
      const container2 = this._container;
      if (!container2.audioContext) {
        return;
      }
      for (const source of this._audioSources) {
        this._removeAudioSource(source);
      }
      if (this._gain) {
        this._gain.disconnect();
      }
      container2.audioContext.close();
      container2.audioContext = void 0;
      this._engine.dispatchEvent("soundsMuted", { container: this._container });
    };
    this._playBuffer = (audio) => {
      const audioBuffer = this._audioMap.get(audio.source);
      if (!audioBuffer) {
        return;
      }
      const audioCtx = this._container.audioContext;
      if (!audioCtx) {
        return;
      }
      const source = this._addBuffer(audioCtx);
      source.loop = audio.loop;
      source.buffer = audioBuffer;
      source.connect(this._gain ?? audioCtx.destination);
      source.start();
    };
    this._playFrequency = async (frequency, duration) => {
      if (!this._container.audioContext || !this._gain) {
        return;
      }
      const oscillator = this._addOscillator(this._container.audioContext);
      oscillator.connect(this._gain);
      oscillator.type = "sine";
      oscillator.frequency.value = frequency;
      oscillator.start();
      return new Promise((resolve) => {
        setTimeout(() => {
          this._removeAudioSource(oscillator);
          resolve();
        }, duration);
      });
    };
    this._playMuteSound = () => {
      const container2 = this._container;
      if (!container2.audioContext) {
        return;
      }
      const gain = container2.audioContext.createGain();
      gain.connect(container2.audioContext.destination);
      gain.gain.value = 0;
      const oscillator = container2.audioContext.createOscillator();
      oscillator.connect(gain);
      oscillator.type = "sine";
      oscillator.frequency.value = 1;
      oscillator.start();
      setTimeout(() => {
        oscillator.stop();
        oscillator.disconnect();
        gain.disconnect();
      });
    };
    this._playNote = async (notes2, noteIdx, loop) => {
      if (this._container.muted) {
        return;
      }
      const note = notes2[noteIdx];
      if (!note) {
        return;
      }
      const value = note.value;
      const promises = executeOnSingleOrMultiple(value, async (_, idx) => {
        return this._playNoteValue(notes2, noteIdx, idx);
      });
      await (isArray(promises) ? Promise.allSettled(promises) : promises);
      let nextNoteIdx = noteIdx + 1;
      if (loop && nextNoteIdx >= notes2.length) {
        nextNoteIdx = nextNoteIdx % notes2.length;
      }
      if (this._container.muted) {
        return;
      }
      await this._playNote(notes2, nextNoteIdx, loop);
    };
    this._playNoteValue = async (notes2, noteIdx, valueIdx) => {
      const note = notes2[noteIdx];
      if (!note) {
        return;
      }
      const value = itemFromSingleOrMultiple(note.value, valueIdx, true);
      try {
        const freq = getNoteFrequency(value);
        if (!isNumber(freq)) {
          return;
        }
        await this._playFrequency(freq, note.duration);
      } catch (e) {
        getLogger().error(e);
      }
    };
    this._removeAudioSource = (source) => {
      source.stop();
      source.disconnect();
      this._audioSources.splice(this._audioSources.indexOf(source), 1);
    };
    this._unmute = () => {
      const container2 = this._container, options2 = container2.actualOptions, soundsOptions = options2.sounds;
      if (!soundsOptions) {
        return;
      }
      if (!container2.audioContext) {
        container2.audioContext = new AudioContext();
      }
      const { audioContext } = container2;
      if (!this._audioSources) {
        this._audioSources = [];
      }
      const gain = audioContext.createGain();
      gain.connect(audioContext.destination);
      gain.gain.value = soundsOptions.volume.value / 100;
      this._gain = gain;
      this._initEvents();
      this._engine.dispatchEvent("soundsUnmuted", { container: this._container });
    };
    this._updateMuteIcons = () => {
      const container2 = this._container, muteImg = this._muteImg, unmuteImg = this._unmuteImg;
      if (muteImg) {
        muteImg.style.display = container2.muted ? "block" : "none";
      }
      if (unmuteImg) {
        unmuteImg.style.display = container2.muted ? "none" : "block";
      }
    };
    this._updateMuteStatus = () => {
      const container2 = this._container;
      if (container2.muted) {
        this._mute();
      } else {
        this._unmute();
        this._playMuteSound();
      }
    };
    this._updateVolume = () => {
      var _a;
      const container2 = this._container, soundsOptions = container2.actualOptions.sounds;
      if (!(soundsOptions == null ? void 0 : soundsOptions.enable)) {
        return;
      }
      clamp(this._volume, soundsOptions.volume.min, soundsOptions.volume.max);
      let stateChanged = false;
      if (this._volume <= 0 && !container2.muted) {
        this._volume = 0;
        container2.muted = true;
        stateChanged = true;
      } else if (this._volume > 0 && container2.muted) {
        container2.muted = false;
        stateChanged = true;
      }
      if (stateChanged) {
        this._updateMuteIcons();
        this._updateMuteStatus();
      }
      if ((_a = this._gain) == null ? void 0 : _a.gain) {
        this._gain.gain.value = this._volume / 100;
      }
    };
    this._container = container;
    this._engine = engine;
    this._volume = 0;
    this._audioSources = [];
    this._audioMap = /* @__PURE__ */ new Map();
  }
  async init() {
    const container = this._container, options2 = container.actualOptions, soundsOptions = options2.sounds;
    if (!(soundsOptions == null ? void 0 : soundsOptions.enable)) {
      return;
    }
    this._volume = soundsOptions.volume.value;
    const events = soundsOptions.events;
    this._audioMap = /* @__PURE__ */ new Map();
    for (const event of events) {
      if (!event.audio) {
        continue;
      }
      executeOnSingleOrMultiple(event.audio, async (audio) => {
        const response = await fetch(audio.source);
        if (!response.ok) {
          return;
        }
        const arrayBuffer = await response.arrayBuffer();
        container.audioContext = new AudioContext();
        const audioBuffer = await container.audioContext.decodeAudioData(arrayBuffer);
        this._audioMap.set(audio.source, audioBuffer);
      });
    }
  }
  async start() {
    const container = this._container, options2 = container.actualOptions, soundsOptions = options2.sounds;
    if (!(soundsOptions == null ? void 0 : soundsOptions.enable) || !container.canvas.element) {
      return;
    }
    container.muted = true;
    const canvas = container.canvas.element, pos = {
      top: canvas.offsetTop,
      right: canvas.offsetLeft + canvas.offsetWidth
    }, { mute, unmute, volumeDown, volumeUp } = soundsOptions.icons, margin = 10;
    const toggleMute = () => {
      container.muted = !container.muted;
      this._updateMuteIcons();
      this._updateMuteStatus();
    };
    this._muteImg = initImage({
      container,
      options: options2,
      pos,
      display: "block",
      iconOptions: mute,
      margin,
      rightOffsets: [volumeDown.width, volumeUp.width],
      clickCb: toggleMute
    });
    this._unmuteImg = initImage({
      container,
      options: options2,
      pos,
      display: "none",
      iconOptions: unmute,
      margin,
      rightOffsets: [volumeDown.width, volumeUp.width],
      clickCb: toggleMute
    });
    this._volumeDownImg = initImage({
      container,
      options: options2,
      pos,
      display: "block",
      iconOptions: volumeDown,
      margin,
      rightOffsets: [volumeUp.width],
      clickCb: () => {
        if (container.muted) {
          this._volume = 0;
        }
        this._volume -= soundsOptions.volume.step;
        this._updateVolume();
      }
    });
    this._volumeUpImg = initImage({
      container,
      options: options2,
      pos,
      display: "block",
      iconOptions: volumeUp,
      margin,
      rightOffsets: [],
      clickCb: () => {
        if (container.muted) {
          this._volume = 0;
        }
        this._volume += soundsOptions.volume.step;
        this._updateVolume();
      }
    });
  }
  stop() {
    this._container.muted = true;
    this._mute();
    removeImage(this._muteImg);
    removeImage(this._unmuteImg);
    removeImage(this._volumeDownImg);
    removeImage(this._volumeUpImg);
  }
};

// node_modules/tsparticles-plugin-sounds/esm/index.js
var SoundsPlugin = class {
  constructor(engine) {
    this.id = "sounds";
    this._engine = engine;
  }
  getPlugin(container) {
    return new SoundsInstance(container, this._engine);
  }
  loadOptions(options2, source) {
    if (!this.needsPlugin(options2) && !this.needsPlugin(source)) {
      return;
    }
    let soundsOptions = options2.sounds;
    if ((soundsOptions == null ? void 0 : soundsOptions.load) === void 0) {
      options2.sounds = soundsOptions = new Sounds();
    }
    soundsOptions.load(source == null ? void 0 : source.sounds);
  }
  needsPlugin(options2) {
    var _a;
    return ((_a = options2 == null ? void 0 : options2.sounds) == null ? void 0 : _a.enable) ?? false;
  }
};
async function loadSoundsPlugin(engine, refresh = true) {
  await engine.addPlugin(new SoundsPlugin(engine), refresh);
}

// node_modules/tsparticles-updater-stroke-color/esm/Utils.js
function updateColorValue(delta, colorValue, valueAnimation, max, decrease) {
  if (!colorValue || !valueAnimation.enable || (colorValue.maxLoops ?? 0) > 0 && (colorValue.loops ?? 0) > (colorValue.maxLoops ?? 0)) {
    return;
  }
  if (!colorValue.time) {
    colorValue.time = 0;
  }
  if ((colorValue.delayTime ?? 0) > 0 && colorValue.time < (colorValue.delayTime ?? 0)) {
    colorValue.time += delta.value;
  }
  if ((colorValue.delayTime ?? 0) > 0 && colorValue.time < (colorValue.delayTime ?? 0)) {
    return;
  }
  const offset = randomInRange(valueAnimation.offset), velocity = (colorValue.velocity ?? 0) * delta.factor + offset * 3.6, decay = colorValue.decay ?? 1;
  if (!decrease || colorValue.status === "increasing") {
    colorValue.value += velocity;
    if (colorValue.value > max) {
      if (!colorValue.loops) {
        colorValue.loops = 0;
      }
      colorValue.loops++;
      if (decrease) {
        colorValue.status = "decreasing";
        colorValue.value -= colorValue.value % max;
      }
    }
  } else {
    colorValue.value -= velocity;
    if (colorValue.value < 0) {
      if (!colorValue.loops) {
        colorValue.loops = 0;
      }
      colorValue.loops++;
      colorValue.status = "increasing";
      colorValue.value += colorValue.value;
    }
  }
  if (colorValue.velocity && decay !== 1) {
    colorValue.velocity *= decay;
  }
  if (colorValue.value > max) {
    colorValue.value %= max;
  }
}
function updateStrokeColor(particle, delta) {
  if (!particle.strokeColor || !particle.strokeAnimation) {
    return;
  }
  const { h, s, l } = particle.strokeColor, { h: hAnimation, s: sAnimation, l: lAnimation } = particle.strokeAnimation;
  if (h) {
    updateColorValue(delta, h, hAnimation, 360, false);
  }
  if (s) {
    updateColorValue(delta, s, sAnimation, 100, true);
  }
  if (l) {
    updateColorValue(delta, l, lAnimation, 100, true);
  }
}

// node_modules/tsparticles-updater-stroke-color/esm/StrokeColorUpdater.js
var StrokeColorUpdater = class {
  constructor(container) {
    this.container = container;
  }
  init(particle) {
    var _a;
    const container = this.container, options2 = particle.options;
    const stroke = itemFromSingleOrMultiple(options2.stroke, particle.id, options2.reduceDuplicates);
    particle.strokeWidth = getRangeValue(stroke.width) * container.retina.pixelRatio;
    particle.strokeOpacity = getRangeValue(stroke.opacity ?? 1);
    particle.strokeAnimation = (_a = stroke.color) == null ? void 0 : _a.animation;
    const strokeHslColor = rangeColorToHsl(stroke.color) ?? particle.getFillColor();
    if (strokeHslColor) {
      particle.strokeColor = getHslAnimationFromHsl(strokeHslColor, particle.strokeAnimation, container.retina.reduceFactor);
    }
  }
  isEnabled(particle) {
    const color = particle.strokeAnimation, { strokeColor } = particle;
    return !particle.destroyed && !particle.spawning && !!color && ((strokeColor == null ? void 0 : strokeColor.h.value) !== void 0 && strokeColor.h.enable || (strokeColor == null ? void 0 : strokeColor.s.value) !== void 0 && strokeColor.s.enable || (strokeColor == null ? void 0 : strokeColor.l.value) !== void 0 && strokeColor.l.enable);
  }
  update(particle, delta) {
    if (!this.isEnabled(particle)) {
      return;
    }
    updateStrokeColor(particle, delta);
  }
};

// node_modules/tsparticles-updater-stroke-color/esm/index.js
async function loadStrokeColorUpdater(engine, refresh = true) {
  await engine.addParticleUpdater("strokeColor", (container) => new StrokeColorUpdater(container), refresh);
}

// node_modules/tsparticles-preset-fireworks/esm/options.js
var explodeSoundCheck = (args) => {
  const data = args.data;
  return data.particle.shape === "line";
};
var fixRange = (value, min, max) => {
  const diffSMax = value.max > max ? value.max - max : 0;
  let res = setRangeValue(value);
  if (diffSMax) {
    res = setRangeValue(value.min - diffSMax, max);
  }
  const diffSMin = value.min < min ? value.min : 0;
  if (diffSMin) {
    res = setRangeValue(0, value.max + diffSMin);
  }
  return res;
};
var fireworksOptions = ["#ff595e", "#ffca3a", "#8ac926", "#1982c4", "#6a4c93"].map((color) => {
  const rgb = stringToRgb(color);
  if (!rgb) {
    return void 0;
  }
  const hsl = rgbToHsl(rgb), sRange = fixRange({ min: hsl.s - 30, max: hsl.s + 30 }, 0, 100), lRange = fixRange({ min: hsl.l - 30, max: hsl.l + 30 }, 0, 100);
  return {
    color: {
      value: {
        h: hsl.h,
        s: sRange,
        l: lRange
      }
    },
    stroke: {
      width: 0
    },
    number: {
      value: 0
    },
    opacity: {
      value: {
        min: 0.1,
        max: 1
      },
      animation: {
        enable: true,
        speed: 0.7,
        sync: false,
        startValue: "max",
        destroy: "min"
      }
    },
    shape: {
      type: "circle"
    },
    size: {
      value: { min: 1, max: 2 },
      animation: {
        enable: true,
        speed: 5,
        count: 1,
        sync: false,
        startValue: "min",
        destroy: "none"
      }
    },
    life: {
      count: 1,
      duration: {
        value: {
          min: 1,
          max: 2
        }
      }
    },
    move: {
      decay: { min: 0.075, max: 0.1 },
      enable: true,
      gravity: {
        enable: true,
        inverse: false,
        acceleration: 5
      },
      speed: { min: 5, max: 15 },
      direction: "none",
      outModes: "destroy"
    }
  };
}).filter((t) => t !== void 0);
var options = {
  detectRetina: true,
  background: {
    color: "#000"
  },
  fpsLimit: 120,
  emitters: {
    direction: "top",
    life: {
      count: 0,
      duration: 0.1,
      delay: 0.1
    },
    rate: {
      delay: 0.05,
      quantity: 1
    },
    size: {
      width: 100,
      height: 0
    },
    position: {
      y: 100,
      x: 50
    }
  },
  particles: {
    number: {
      value: 0
    },
    destroy: {
      mode: "split",
      bounds: {
        top: { min: 10, max: 30 }
      },
      split: {
        sizeOffset: false,
        count: 1,
        factor: {
          value: 0.333333
        },
        rate: {
          value: { min: 75, max: 150 }
        },
        particles: fireworksOptions
      }
    },
    life: {
      count: 1
    },
    shape: {
      type: "line"
    },
    size: {
      value: {
        min: 0.1,
        max: 50
      },
      animation: {
        enable: true,
        sync: true,
        speed: 90,
        startValue: "max",
        destroy: "min"
      }
    },
    stroke: {
      color: {
        value: "#ffffff"
      },
      width: 1
    },
    rotate: {
      path: true
    },
    move: {
      enable: true,
      gravity: {
        acceleration: 15,
        enable: true,
        inverse: true,
        maxSpeed: 100
      },
      speed: {
        min: 10,
        max: 20
      },
      outModes: {
        default: "destroy",
        top: "none"
      },
      trail: {
        fillColor: "#000",
        enable: true,
        length: 10
      }
    }
  },
  sounds: {
    enable: true,
    events: [
      {
        event: "particleRemoved",
        filter: explodeSoundCheck,
        audio: [
          "https://particles.js.org/audio/explosion0.mp3",
          "https://particles.js.org/audio/explosion1.mp3",
          "https://particles.js.org/audio/explosion2.mp3"
        ]
      }
    ],
    volume: 50
  }
};

// node_modules/tsparticles-preset-fireworks/esm/index.js
async function loadFireworksPreset(engine, refresh = true) {
  await loadBasic(engine, false);
  await loadEmittersPlugin(engine, false);
  await loadSoundsPlugin(engine, false);
  await loadLineShape(engine, false);
  await loadRotateUpdater(engine, false);
  await loadDestroyUpdater(engine, false);
  await loadLifeUpdater(engine, false);
  await loadStrokeColorUpdater(engine, false);
  await engine.addPreset("fireworks", options, refresh);
}
export {
  loadFireworksPreset
};
//# sourceMappingURL=tsparticles-preset-fireworks.js.map
