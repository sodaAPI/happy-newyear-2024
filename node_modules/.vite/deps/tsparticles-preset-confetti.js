import {
  loadEmittersPlugin,
  loadLifeUpdater,
  loadRotateUpdater
} from "./chunk-FJ7BXDON.js";
import {
  loadBasic
} from "./chunk-OXELOQTJ.js";
import {
  OptionsColor,
  ValueWithRandom,
  getRandom,
  getRangeValue,
  isNumber,
  rangeColorToHsl,
  safeMatchMedia,
  setRangeValue
} from "./chunk-ADUCJV7J.js";
import "./chunk-LQ2VYIYD.js";

// node_modules/tsparticles-plugin-motion/esm/Options/Classes/MotionReduce.js
var MotionReduce = class {
  constructor() {
    this.factor = 4;
    this.value = true;
  }
  load(data) {
    if (!data) {
      return;
    }
    if (data.factor !== void 0) {
      this.factor = data.factor;
    }
    if (data.value !== void 0) {
      this.value = data.value;
    }
  }
};

// node_modules/tsparticles-plugin-motion/esm/Options/Classes/Motion.js
var Motion = class {
  constructor() {
    this.disable = false;
    this.reduce = new MotionReduce();
  }
  load(data) {
    if (!data) {
      return;
    }
    if (data.disable !== void 0) {
      this.disable = data.disable;
    }
    this.reduce.load(data.reduce);
  }
};

// node_modules/tsparticles-plugin-motion/esm/MotionInstance.js
var MotionInstance = class {
  constructor(container, engine) {
    this._handleMotionChange = (mediaQuery) => {
      const container2 = this._container, motion = container2.actualOptions.motion;
      if (!motion) {
        return;
      }
      container2.retina.reduceFactor = mediaQuery.matches ? motion.disable ? 0 : motion.reduce.value ? 1 / motion.reduce.factor : 1 : 1;
    };
    this._container = container;
    this._engine = engine;
  }
  async init() {
    const container = this._container, options2 = container.actualOptions.motion;
    if (!(options2 && (options2.disable || options2.reduce.value))) {
      container.retina.reduceFactor = 1;
      return;
    }
    const mediaQuery = safeMatchMedia("(prefers-reduced-motion: reduce)");
    if (!mediaQuery) {
      container.retina.reduceFactor = 1;
      return;
    }
    this._handleMotionChange(mediaQuery);
    const handleChange = async () => {
      this._handleMotionChange(mediaQuery);
      try {
        await container.refresh();
      } catch {
      }
    };
    if (mediaQuery.addEventListener !== void 0) {
      mediaQuery.addEventListener("change", handleChange);
    } else if (mediaQuery.addListener !== void 0) {
      mediaQuery.addListener(handleChange);
    }
  }
};

// node_modules/tsparticles-plugin-motion/esm/index.js
var MotionPlugin = class {
  constructor(engine) {
    this.id = "motion";
    this._engine = engine;
  }
  getPlugin(container) {
    return new MotionInstance(container, this._engine);
  }
  loadOptions(options2, source) {
    if (!this.needsPlugin()) {
      return;
    }
    let motionOptions = options2.motion;
    if (!(motionOptions == null ? void 0 : motionOptions.load)) {
      options2.motion = motionOptions = new Motion();
    }
    motionOptions.load(source == null ? void 0 : source.motion);
  }
  needsPlugin() {
    return true;
  }
};
async function loadMotionPlugin(engine, refresh = true) {
  await engine.addPlugin(new MotionPlugin(engine), refresh);
}

// node_modules/tsparticles-updater-roll/esm/Utils.js
function initParticle(particle) {
  const rollOpt = particle.options.roll;
  if (!(rollOpt == null ? void 0 : rollOpt.enable)) {
    particle.roll = {
      enable: false,
      horizontal: false,
      vertical: false,
      angle: 0,
      speed: 0
    };
    return;
  }
  particle.roll = {
    enable: rollOpt.enable,
    horizontal: rollOpt.mode === "horizontal" || rollOpt.mode === "both",
    vertical: rollOpt.mode === "vertical" || rollOpt.mode === "both",
    angle: getRandom() * Math.PI * 2,
    speed: getRangeValue(rollOpt.speed) / 360
  };
  if (rollOpt.backColor) {
    particle.backColor = rangeColorToHsl(rollOpt.backColor);
  } else if (rollOpt.darken.enable && rollOpt.enlighten.enable) {
    const alterType = getRandom() >= 0.5 ? "darken" : "enlighten";
    particle.roll.alter = {
      type: alterType,
      value: getRangeValue(alterType === "darken" ? rollOpt.darken.value : rollOpt.enlighten.value)
    };
  } else if (rollOpt.darken.enable) {
    particle.roll.alter = {
      type: "darken",
      value: getRangeValue(rollOpt.darken.value)
    };
  } else if (rollOpt.enlighten.enable) {
    particle.roll.alter = {
      type: "enlighten",
      value: getRangeValue(rollOpt.enlighten.value)
    };
  }
}
function updateRoll(particle, delta) {
  const roll = particle.options.roll, data = particle.roll;
  if (!data || !(roll == null ? void 0 : roll.enable)) {
    return;
  }
  const speed = data.speed * delta.factor, max = 2 * Math.PI;
  data.angle += speed;
  if (data.angle > max) {
    data.angle -= max;
  }
}

// node_modules/tsparticles-updater-roll/esm/Options/Classes/RollLight.js
var RollLight = class {
  constructor() {
    this.enable = false;
    this.value = 0;
  }
  load(data) {
    if (!data) {
      return;
    }
    if (data.enable !== void 0) {
      this.enable = data.enable;
    }
    if (data.value !== void 0) {
      this.value = setRangeValue(data.value);
    }
  }
};

// node_modules/tsparticles-updater-roll/esm/Options/Classes/Roll.js
var Roll = class {
  constructor() {
    this.darken = new RollLight();
    this.enable = false;
    this.enlighten = new RollLight();
    this.mode = "vertical";
    this.speed = 25;
  }
  load(data) {
    if (!data) {
      return;
    }
    if (data.backColor !== void 0) {
      this.backColor = OptionsColor.create(this.backColor, data.backColor);
    }
    this.darken.load(data.darken);
    if (data.enable !== void 0) {
      this.enable = data.enable;
    }
    this.enlighten.load(data.enlighten);
    if (data.mode !== void 0) {
      this.mode = data.mode;
    }
    if (data.speed !== void 0) {
      this.speed = setRangeValue(data.speed);
    }
  }
};

// node_modules/tsparticles-updater-roll/esm/RollUpdater.js
var RollUpdater = class {
  getTransformValues(particle) {
    var _a;
    const roll = ((_a = particle.roll) == null ? void 0 : _a.enable) && particle.roll, rollHorizontal = roll && roll.horizontal, rollVertical = roll && roll.vertical;
    return {
      a: rollHorizontal ? Math.cos(roll.angle) : void 0,
      d: rollVertical ? Math.sin(roll.angle) : void 0
    };
  }
  init(particle) {
    initParticle(particle);
  }
  isEnabled(particle) {
    const roll = particle.options.roll;
    return !particle.destroyed && !particle.spawning && !!(roll == null ? void 0 : roll.enable);
  }
  loadOptions(options2, ...sources) {
    if (!options2.roll) {
      options2.roll = new Roll();
    }
    for (const source of sources) {
      options2.roll.load(source == null ? void 0 : source.roll);
    }
  }
  update(particle, delta) {
    if (!this.isEnabled(particle)) {
      return;
    }
    updateRoll(particle, delta);
  }
};

// node_modules/tsparticles-updater-roll/esm/index.js
async function loadRollUpdater(engine, refresh = true) {
  await engine.addParticleUpdater("roll", () => new RollUpdater(), refresh);
}

// node_modules/tsparticles-shape-square/esm/SquareDrawer.js
var fixFactor = Math.sqrt(2);
var SquareDrawer = class {
  draw(context, particle, radius) {
    const fixedRadius = radius / fixFactor, fixedDiameter = fixedRadius * 2;
    context.rect(-fixedRadius, -fixedRadius, fixedDiameter, fixedDiameter);
  }
  getSidesCount() {
    return 4;
  }
};

// node_modules/tsparticles-shape-square/esm/index.js
async function loadSquareShape(engine, refresh = true) {
  await engine.addShape(["edge", "square"], new SquareDrawer(), refresh);
}

// node_modules/tsparticles-updater-tilt/esm/Options/Classes/TiltAnimation.js
var TiltAnimation = class {
  constructor() {
    this.enable = false;
    this.speed = 0;
    this.decay = 0;
    this.sync = false;
  }
  load(data) {
    if (!data) {
      return;
    }
    if (data.enable !== void 0) {
      this.enable = data.enable;
    }
    if (data.speed !== void 0) {
      this.speed = setRangeValue(data.speed);
    }
    if (data.decay !== void 0) {
      this.decay = setRangeValue(data.decay);
    }
    if (data.sync !== void 0) {
      this.sync = data.sync;
    }
  }
};

// node_modules/tsparticles-updater-tilt/esm/Options/Classes/Tilt.js
var Tilt = class extends ValueWithRandom {
  constructor() {
    super();
    this.animation = new TiltAnimation();
    this.direction = "clockwise";
    this.enable = false;
    this.value = 0;
  }
  load(data) {
    super.load(data);
    if (!data) {
      return;
    }
    this.animation.load(data.animation);
    if (data.direction !== void 0) {
      this.direction = data.direction;
    }
    if (data.enable !== void 0) {
      this.enable = data.enable;
    }
  }
};

// node_modules/tsparticles-updater-tilt/esm/Utils.js
function updateTilt(particle, delta) {
  if (!particle.tilt || !particle.options.tilt) {
    return;
  }
  const tilt = particle.options.tilt, tiltAnimation = tilt.animation, speed = (particle.tilt.velocity ?? 0) * delta.factor, max = 2 * Math.PI, decay = particle.tilt.decay ?? 1;
  if (!tiltAnimation.enable) {
    return;
  }
  switch (particle.tilt.status) {
    case "increasing":
      particle.tilt.value += speed;
      if (particle.tilt.value > max) {
        particle.tilt.value -= max;
      }
      break;
    case "decreasing":
    default:
      particle.tilt.value -= speed;
      if (particle.tilt.value < 0) {
        particle.tilt.value += max;
      }
      break;
  }
  if (particle.tilt.velocity && decay !== 1) {
    particle.tilt.velocity *= decay;
  }
}

// node_modules/tsparticles-updater-tilt/esm/TiltUpdater.js
var TiltUpdater = class {
  constructor(container) {
    this.container = container;
  }
  getTransformValues(particle) {
    var _a;
    const tilt = ((_a = particle.tilt) == null ? void 0 : _a.enable) && particle.tilt;
    return {
      b: tilt ? Math.cos(tilt.value) * tilt.cosDirection : void 0,
      c: tilt ? Math.sin(tilt.value) * tilt.sinDirection : void 0
    };
  }
  init(particle) {
    var _a;
    const tiltOptions = particle.options.tilt;
    if (!tiltOptions) {
      return;
    }
    particle.tilt = {
      enable: tiltOptions.enable,
      value: getRangeValue(tiltOptions.value) * Math.PI / 180,
      sinDirection: getRandom() >= 0.5 ? 1 : -1,
      cosDirection: getRandom() >= 0.5 ? 1 : -1
    };
    let tiltDirection = tiltOptions.direction;
    if (tiltDirection === "random") {
      const index = Math.floor(getRandom() * 2);
      tiltDirection = index > 0 ? "counter-clockwise" : "clockwise";
    }
    switch (tiltDirection) {
      case "counter-clockwise":
      case "counterClockwise":
        particle.tilt.status = "decreasing";
        break;
      case "clockwise":
        particle.tilt.status = "increasing";
        break;
    }
    const tiltAnimation = (_a = particle.options.tilt) == null ? void 0 : _a.animation;
    if (tiltAnimation == null ? void 0 : tiltAnimation.enable) {
      particle.tilt.decay = 1 - getRangeValue(tiltAnimation.decay);
      particle.tilt.velocity = getRangeValue(tiltAnimation.speed) / 360 * this.container.retina.reduceFactor;
      if (!tiltAnimation.sync) {
        particle.tilt.velocity *= getRandom();
      }
    }
  }
  isEnabled(particle) {
    var _a;
    const tiltAnimation = (_a = particle.options.tilt) == null ? void 0 : _a.animation;
    return !particle.destroyed && !particle.spawning && !!(tiltAnimation == null ? void 0 : tiltAnimation.enable);
  }
  loadOptions(options2, ...sources) {
    if (!options2.tilt) {
      options2.tilt = new Tilt();
    }
    for (const source of sources) {
      options2.tilt.load(source == null ? void 0 : source.tilt);
    }
  }
  update(particle, delta) {
    if (!this.isEnabled(particle)) {
      return;
    }
    updateTilt(particle, delta);
  }
};

// node_modules/tsparticles-updater-tilt/esm/index.js
async function loadTiltUpdater(engine, refresh = true) {
  await engine.addParticleUpdater("tilt", (container) => new TiltUpdater(container), refresh);
}

// node_modules/tsparticles-updater-wobble/esm/Options/Classes/WobbleSpeed.js
var WobbleSpeed = class {
  constructor() {
    this.angle = 50;
    this.move = 10;
  }
  load(data) {
    if (!data) {
      return;
    }
    if (data.angle !== void 0) {
      this.angle = setRangeValue(data.angle);
    }
    if (data.move !== void 0) {
      this.move = setRangeValue(data.move);
    }
  }
};

// node_modules/tsparticles-updater-wobble/esm/Options/Classes/Wobble.js
var Wobble = class {
  constructor() {
    this.distance = 5;
    this.enable = false;
    this.speed = new WobbleSpeed();
  }
  load(data) {
    if (!data) {
      return;
    }
    if (data.distance !== void 0) {
      this.distance = setRangeValue(data.distance);
    }
    if (data.enable !== void 0) {
      this.enable = data.enable;
    }
    if (data.speed !== void 0) {
      if (isNumber(data.speed)) {
        this.speed.load({ angle: data.speed });
      } else {
        const rangeSpeed = data.speed;
        if (rangeSpeed.min !== void 0) {
          this.speed.load({ angle: rangeSpeed });
        } else {
          this.speed.load(data.speed);
        }
      }
    }
  }
};

// node_modules/tsparticles-updater-wobble/esm/Utils.js
function updateWobble(particle, delta) {
  const { wobble: wobbleOptions } = particle.options, { wobble } = particle;
  if (!(wobbleOptions == null ? void 0 : wobbleOptions.enable) || !wobble) {
    return;
  }
  const angleSpeed = wobble.angleSpeed * delta.factor, moveSpeed = wobble.moveSpeed * delta.factor, distance = moveSpeed * ((particle.retina.wobbleDistance ?? 0) * delta.factor) / (1e3 / 60), max = 2 * Math.PI, { position } = particle;
  wobble.angle += angleSpeed;
  if (wobble.angle > max) {
    wobble.angle -= max;
  }
  position.x += distance * Math.cos(wobble.angle);
  position.y += distance * Math.abs(Math.sin(wobble.angle));
}

// node_modules/tsparticles-updater-wobble/esm/WobbleUpdater.js
var WobbleUpdater = class {
  constructor(container) {
    this.container = container;
  }
  init(particle) {
    const wobbleOpt = particle.options.wobble;
    if (wobbleOpt == null ? void 0 : wobbleOpt.enable) {
      particle.wobble = {
        angle: getRandom() * Math.PI * 2,
        angleSpeed: getRangeValue(wobbleOpt.speed.angle) / 360,
        moveSpeed: getRangeValue(wobbleOpt.speed.move) / 10
      };
    } else {
      particle.wobble = {
        angle: 0,
        angleSpeed: 0,
        moveSpeed: 0
      };
    }
    particle.retina.wobbleDistance = getRangeValue((wobbleOpt == null ? void 0 : wobbleOpt.distance) ?? 0) * this.container.retina.pixelRatio;
  }
  isEnabled(particle) {
    var _a;
    return !particle.destroyed && !particle.spawning && !!((_a = particle.options.wobble) == null ? void 0 : _a.enable);
  }
  loadOptions(options2, ...sources) {
    if (!options2.wobble) {
      options2.wobble = new Wobble();
    }
    for (const source of sources) {
      options2.wobble.load(source == null ? void 0 : source.wobble);
    }
  }
  update(particle, delta) {
    if (!this.isEnabled(particle)) {
      return;
    }
    updateWobble(particle, delta);
  }
};

// node_modules/tsparticles-updater-wobble/esm/index.js
async function loadWobbleUpdater(engine, refresh = true) {
  await engine.addParticleUpdater("wobble", (container) => new WobbleUpdater(container), refresh);
}

// node_modules/tsparticles-preset-confetti/esm/options.js
var options = {
  fullScreen: {
    enable: true,
    zIndex: 100
  },
  fpsLimit: 120,
  particles: {
    number: {
      value: 0
    },
    color: {
      value: ["#26ccff", "#a25afd", "#ff5e7e", "#88ff5a", "#fcff42", "#ffa62d", "#ff36ff"]
    },
    shape: {
      type: ["square", "circle"]
    },
    opacity: {
      value: { min: 0, max: 1 },
      animation: {
        enable: true,
        speed: 0.5,
        startValue: "max",
        destroy: "min"
      }
    },
    size: {
      value: 5
    },
    links: {
      enable: false
    },
    life: {
      duration: {
        sync: true,
        value: 20 / 6
      },
      count: 1
    },
    move: {
      angle: {
        value: 45,
        offset: 0
      },
      drift: 0,
      enable: true,
      gravity: {
        enable: true,
        acceleration: 9.81
      },
      speed: 45,
      decay: 0.1,
      direction: -90,
      random: true,
      straight: false,
      outModes: {
        default: "none",
        bottom: "destroy"
      }
    },
    rotate: {
      value: {
        min: 0,
        max: 360
      },
      direction: "random",
      animation: {
        enable: true,
        speed: 60
      }
    },
    tilt: {
      direction: "random",
      enable: true,
      value: {
        min: 0,
        max: 360
      },
      animation: {
        enable: true,
        speed: 60
      }
    },
    roll: {
      darken: {
        enable: true,
        value: 25
      },
      enable: true,
      speed: {
        min: 15,
        max: 25
      }
    },
    wobble: {
      distance: 30,
      enable: true,
      speed: {
        min: -15,
        max: 15
      }
    }
  },
  detectRetina: true,
  motion: {
    disable: true
  },
  emitters: {
    name: "confetti",
    startCount: 50,
    position: {
      x: 50,
      y: 50
    },
    size: {
      width: 0,
      height: 0
    },
    rate: {
      delay: 0,
      quantity: 0
    },
    life: {
      duration: 0.1,
      count: 1
    }
  }
};

// node_modules/tsparticles-preset-confetti/esm/index.js
async function loadPreset(engine, refresh = true) {
  await loadBasic(engine, false);
  await loadSquareShape(engine, false);
  await loadEmittersPlugin(engine, false);
  await loadMotionPlugin(engine, false);
  await loadWobbleUpdater(engine, false);
  await loadRollUpdater(engine, false);
  await loadRotateUpdater(engine, false);
  await loadTiltUpdater(engine, false);
  await loadLifeUpdater(engine, false);
  await engine.addPreset("confetti", options, refresh);
}
async function loadConfettiPreset(engine) {
  await loadPreset(engine);
}
export {
  loadConfettiPreset
};
//# sourceMappingURL=tsparticles-preset-confetti.js.map
